排序：将一组"无序"的记录序列调整为"有序"的记录序列
列表排序：将无序列表变为有序列表
输入：列表
输出：有序列表

升序与降序
内置排序函数：sort()

常见排序算法
low B排序三人组：冒泡排序 选择排序 插入排序
NB 排序三人组：快速排序 堆排序 归并排序
其他排序：希尔排序 计数排序 基数排序

low B排序三人组：
    1. 冒泡排序：列表每两个相邻的数，如果前面比后面大，则交换这两个数
        一趟排序完成后，则无序区减少一个数，有序区增加一个数
        代码关键点：躺 无序区
        时间复杂度：O(n^2)
        优化：如果一趟冒泡排序里没有发生任何交换，我们可以认为列表已经排序完成

    2. 选择排序：
        一趟排序记录最小的数，放到第一个位置
        再一趟排序记录列表无序区最小的数，放到第二个位置
        再。。。。。。
        算法关键点：有序区和无序区 无序区最小数的位置
        时间复杂度：时间复杂度：O(n^2)

    3. 插入排序
        时间复杂度：时间复杂度：O(n^2)

NB三人组：
    1. 快速排序
        快速排序思路：
            取一个元素P（第一个元素） 使元素P归位
            列表被P分成两个部分 左边都比P小 右边都比P大
            递归完成排序（左右两边都需要）
    时间复杂度 O(nlogn) 也有空间复杂度的问题：因为递归的时候也要消耗内存 平均O(logn)最坏情况O(n)
    缺点：1 递归（递归最大深度）
         2 最坏 [9,8,7,6,5,4,3,2,1]每次都只少一个数

    2. 堆排序
    堆排序前传-树与二叉树
    树是一种数据结构 比如：目录结构
    树是一种可以递归定义的数据结构
    树是由n个节点组成的集合
        如果n=0 那这就是一个空树
        如果n>0 那么存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一个树
    一些基本概念：
        根节点 叶子结点（下面没有子节点的节点）
        树的深度（高度）从头到最尾
        节点的度：直属子节点有多少个
        树的度：最大的节点的度
        孩子节点/父节点
        子树
    二叉树：
        度不出超过2的树
        每个节点最多有两个孩子节点
        两个孩子被区分为左孩子节点和右孩子节点
    满二叉树：
        一个二叉树，如果每一个层的节点数都达到了最大值，则这个二叉树就是满二叉树
    完全二叉树：
        叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树

    二叉树的存储方式（表示方式）
        1 链式存储方式
        2 顺序存储方式

    父节点和左孩子节点的编号下标的关系
    i => 2i+1
    父节点和右孩子节点的编号下标的关系
    i => 2i+2

    孩子节点（无论左右）和父节点编号下标的关系
    (i-1) // 2

    堆：一种特殊的完全二叉树结构
        1 大根堆： 一颗完全二叉树，满足任一节点（的值）都比起孩子节点（的值）大
        2 小根堆： 一颗完全二叉树，满足任一节点（的值）都比起孩子节点（的值）小

    堆的向下调整性质：
        假设根节点的左右子树都是堆，但根节点不满足堆的性质
        可以通过一次向下的调整来将其变成一个堆
    构造堆：
        取最后一个非叶子结点 农村包围城市

    堆排序过程：
        1 建立堆
        2 得到堆顶元素，为最大元素
        3 去掉堆顶，将堆的最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
        4 堆顶为第二大元素
        5 重复步骤3 直到堆变空
    时间复杂度：O(nlogn)

    堆排序 -- topk问题
    现在有n个数，设计算法得到前k大的数（k<n）
    解决思路：
        1 排序后切片 O(nlogn)
        2 排序lowB三人组 O(kn)
        3 堆排序的思路 O(nlogk)
            a 取列表前K个元素建立一个小根堆。 堆顶就是目前小根堆的第k大的数（最小的一个数）
            b 依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素，如果大于堆顶，则堆顶更换成该元素，并且对堆进行一次调整

    3. 归并排序
    假设现在的列表分两段有序 如何将其合成为一个有序列表
    这种操作称为一次归并
    时间复杂度：O(nlogn) 空间复杂度：开了一个临时的空间 O(n)

    NB三人组总结：
    三种排序算法的时间复杂度都是O(nlogn)
    一般情况下， 就运行速度而言
    快速排序 < 归并排序 < 堆排序（最慢）
    三种排序算法的缺点
    1 快速排序 极端情况下排序效率低
    2 归并排序 需要额外的内存开销
    3 堆排序 在快的排序算法中比较慢

    稳定性：相同元素的相对位置是否改变 不改变则稳定好
    e.g [3,2,1,2,4] => 排序结束后 两个2的相对是否改变
    冒泡排序 直接插入排序 归并排序 => 稳定 （有顺序挨个换的）
    直接选择排序 快速排序 堆排序 => 不稳定 （无顺序飞着换的）

其他排序：
    1 希尔排序（shell sort）
        首先取一个整数d1=n/2 将元素分成d1个组 每组相邻量元素之间的距离为d1在各组内进行直接插入排序
        去第二个整数d2=d1/2 重复上述的分组排序过程直到di 即所有元素在同一组内进行直接插入排序
    希尔排序每趟并不是某些元素有序 而是使整体数据越来越接近有序 最后一趟排序使得所有数据有序
    574631298 => d1 = 8/2 = 4 => （5   3   8）（7   1）（4   2）（6   9）间隔为4的数字在一组 每组进行插入排序
    =>(312657498) => d2 = d1/2 = 2 => (3 2 5 4 8) (1 6 7 9) ...
    希尔排序的时间复杂度很复杂 与取的gap有关 我在实例中用的gap是2

