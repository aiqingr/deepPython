排序：将一组"无序"的记录序列调整为"有序"的记录序列
列表排序：将无序列表变为有序列表
输入：列表
输出：有序列表

升序与降序
内置排序函数：sort()

常见排序算法
low B排序三人组：冒泡排序 选择排序 插入排序
NB 排序三人组：快速排序 堆排序 归并排序
其他排序：希尔排序 计数排序 基数排序

low B排序三人组：
    1. 冒泡排序：列表每两个相邻的数，如果前面比后面大，则交换这两个数
        一趟排序完成后，则无序区减少一个数，有序区增加一个数
        代码关键点：躺 无序区
        时间复杂度：O(n^2)
        优化：如果一趟冒泡排序里没有发生任何交换，我们可以认为列表已经排序完成

    2. 选择排序：
        一趟排序记录最小的数，放到第一个位置
        再一趟排序记录列表无序区最小的数，放到第二个位置
        再。。。。。。
        算法关键点：有序区和无序区 无序区最小数的位置
        时间复杂度：时间复杂度：O(n^2)

    3. 插入排序
        时间复杂度：时间复杂度：O(n^2)

NB三人组：
    1. 快速排序
        快速排序思路：
            取一个元素P（第一个元素） 使元素P归位
            列表被P分成两个部分 左边都比P小 右边都比P大
            递归完成排序（左右两边都需要）
    时间复杂度 O(nlogn)
    缺点：1 递归（递归最大深度）
         2 最坏 [9,8,7,6,5,4,3,2,1]每次都只少一个数

    对排序前传-树与二叉树
    树是一种数据结构 比如：目录结构
    树是一种可以递归定义的数据结构
    树是由n个节点组成的集合
        如果n=0 那这就是一个空树
        如果n>0 那么存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一个树
    一些基本概念：
        根节点 叶子结点（下面没有子节点的节点）
        树的深度（高度）从头到最尾
        节点的度：直属子节点有多少个
        树的度：最大的节点的度
        孩子节点/父节点
        子树
    二叉树：
        度不出超过2的树
        每个节点最多有两个孩子节点
        两个孩子被区分为左孩子节点和右孩子节点
    满二叉树：
        一个二叉树，如果每一个层的节点数都达到了最大值，则这个二叉树就是满二叉树
    完全二叉树：
        叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树

    二叉树的存储方式（表示方式）
        1 链式存储方式
        2 顺序存储方式

    父节点和左孩子节点的编号下标的关系
    i => 2i+1
    父节点和右孩子节点的编号下标的关系
    i => 2i+2

    孩子节点（无论左右）和父节点编号下标的关系
    (i-1) // 2

    堆：一种特殊的完全二叉树结构
        1 大根堆： 一颗完全二叉树，满足任一节点（的值）都比起孩子节点（的值）大
        2 小根堆： 一颗完全二叉树，满足任一节点（的值）都比起孩子节点（的值）小

    堆的向下调整性质：
        假设根节点的左右子树都是堆，但根节点不满足堆的性质
        可以通过一次向下的调整来将其变成一个堆
    构造堆：
        取最后一个非叶子结点 农村包围城市

    堆排序过程：
        1 建立堆
        2 得到堆顶元素，为最大元素
        3 去掉堆顶，将堆的最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
        4 堆顶为第二大元素
        5 重复步骤3 直到堆变空
    时间复杂度：O(nlogn)